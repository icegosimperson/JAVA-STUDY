### ğŸ“Œ **ì‚¬ìš© ì–¸ì–´** : Java

---
### ğŸ“Œ **ë¬¸ì œ ì •ë³´**
[ê°ì‹œ](https://www.acmicpc.net/problem/15683)

ë¬¸ì œ ìš”ì•½
---
- 1~5ë²ˆ CCTVë¥¼ 90ë„ íšŒì „í•˜ì—¬ CCTV ì‚¬ê° ì§€ëŒ€ë¥¼ ìµœì†Œí™”

ì…ë ¥
----
ì²«ì§¸ ì¤„ì— ì‚¬ë¬´ì‹¤ì˜ ì„¸ë¡œ í¬ê¸° Nê³¼ ê°€ë¡œ í¬ê¸° Mì´ ì£¼ì–´ì§„ë‹¤. (1 â‰¤ N, M â‰¤ 8)

ë‘˜ì§¸ ì¤„ë¶€í„° Nê°œì˜ ì¤„ì—ëŠ” ì‚¬ë¬´ì‹¤ ê° ì¹¸ì˜ ì •ë³´ê°€ ì£¼ì–´ì§„ë‹¤. 0ì€ ë¹ˆ ì¹¸, 6ì€ ë²½, 1~5ëŠ” CCTVë¥¼ ë‚˜íƒ€ë‚´ê³ , ë¬¸ì œì—ì„œ ì„¤ëª…í•œ CCTVì˜ ì¢…ë¥˜ì´ë‹¤.

CCTVì˜ ìµœëŒ€ ê°œìˆ˜ëŠ” 8ê°œë¥¼ ë„˜ì§€ ì•ŠëŠ”ë‹¤.

ì¶œë ¥
----
ì§¸ ì¤„ì— ì‚¬ê° ì§€ëŒ€ì˜ ìµœì†Œ í¬ê¸°ë¥¼ ì¶œë ¥í•œë‹¤.

---

### ğŸ“Œ **ì†ŒìŠ¤ ì½”ë“œ (ì„±ê³µ ì‚¬ë¡€)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

/*
CCTV ì‚¬ê° ì§€ëŒ€ ìµœì†Œí™”
CCTV ë°©í–¥ ì„ íƒ -> DFS -> ë°©í–¥ 8ê°€ì§€ -> ëª¨ë“  ë°©í–¥ ì‹œë„ X -> ë°±íŠ¸ë˜í‚¹
class Main{
    static int N, M;
    static int[][] board;
    static int min = Integer.MAX_VALUE;
    static int[] dx = {1, 0, -1, 0}; // ìš°, ìƒ, ì¢Œ, í•˜
    static int[] dy = {0, 1, 0, -1};
    static class Node{
        int x, y, number;
        Node(int x, int y, int number){
            this.x = x;
            this.y = y;
            this.number = number; // cctv ë²ˆí˜¸
        }
    }

    static List<Node> cctvList = new ArrayList<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        board = new int[N][M];

        for(int i=0; i<N; i++){
            st = new StringTokenizer(br.readLine());
            for(int j=0; j<M; j++){
                board[i][j] = Integer.parseInt(st.nextToken());
                if(1 <= board[i][j] && board[i][j] <=5){
                    cctvList.add(new Node(i, j, board[i][j]));
                }
            }
        }
        dfs(0, board);
        System.out.println(min);
    }
    private static int counting(int[][] board){
        int cnt = 0;

        for(int i=0; i<N; i++){
            for(int j=0; j<M; j++){
                if(board[i][j]==0){
                    cnt++;
                }
            }
        }
        return cnt;
    }
    private static void dfs(int depth, int[][] board){
        if(depth==cctvList.size()){ // base condition
            min = Math.min(min, counting(board));
            return;
        }
        Node cctv = cctvList.get(depth); // í˜„ì¬ CCTV êº¼ëƒ„

        switch (cctv.number){
            case 1:
                for(int d=0; d<4; d++){
                    int[][] copy = copyBoard(board);
                    simulation(copy, cctv.x, cctv.y, d); // ìš°
                    dfs(depth+1, copy);
                }
                break;
            case 2:
                for(int d=0; d<4; d++){
                    int[][] copy = copyBoard(board);
                    simulation(copy, cctv.x, cctv.y, d); // ìš°
                    simulation(copy, cctv.x, cctv.y, (d+2)%4); // ì¢Œ
                    dfs(depth + 1, copy);
                }
                break;
            case 3:
                for(int d=0; d<4; d++){
                    int[][] copy = copyBoard(board);
                    simulation(copy, cctv.x, cctv.y, d); // ìš°
                    simulation(copy, cctv.x, cctv.y, (d+1)%4); // ìƒ
                    dfs(depth + 1, copy);
                }
                break;
            case 4:
                for(int d=0; d<4; d++){
                    int[][] copy = copyBoard(board);
                    simulation(copy, cctv.x, cctv.y, d); // ìš°
                    simulation(copy, cctv.x, cctv.y, (d+1)%4); // ìƒ
                    simulation(copy, cctv.x, cctv.y, (d+2)%4); // ì¢Œ
                    dfs(depth + 1, copy);
                }
                break;
            case 5:
                int[][] copy = copyBoard(board);
                for(int d=0; d<4; d++){
                    simulation(copy, cctv.x, cctv.y, d); // ìƒí•˜ì¢Œìš°
                }
                dfs(depth + 1, copy);
                break;
        }

    }
    private static void simulation(int[][] board, int x, int y, int dir){
        while(true){
            x += dx[dir];
            y += dy[dir];
            if(!isValid(x, y)){ // ê²½ê³„ ë²—ì–´ë‚˜ë©´ ì¢…ë£Œ
                break;
            }
            if(board[x][y]==6){
                break;
            }
            if(board[x][y]==0){ // ê°ì‹œí•œ ëŒ€ìƒ
                board[x][y] = 7; // ê°ì‹œí•œ ì˜ì—­ì„ #ëŒ€ì‹  7ë¡œ ë°”ê¿ˆ
            }
        }
    }
    private static boolean isValid(int x, int y){
        return 0 <= x && x < N && 0 <= y && y < M;
    }
    private static int[][] copyBoard(int[][] board){
        int[][] copyBord = new int[N][M];

        for(int i=0; i<N; i++){
            for(int j=0; j<M; j++){
                copyBord[i][j] = board[i][j];
            }
        }
        return copyBord;
    }
}
```

---
### ğŸ“Œ **ë©”ëª¨ë¦¬ & ì†Œìš” ì‹œê°„**
| ë©”ëª¨ë¦¬     | ê²°ê³¼        |
|----------|-------------|
| ë©”ëª¨ë¦¬   | ì‹¤í–‰ ì‹œê°„  |
| 60384 KB  | 320 ms      |






---
### ğŸ“Œ **ì‹œê°„ ë³µì¡ë„**
- CCTV ë°©í–¥ ì„ íƒ -> DFS -> ë°©í–¥ 8ê°€ì§€ -> ëª¨ë“  ë°©í–¥ ì‹œë„ X -> ë°±íŠ¸ë˜í‚¹
- ì‹œê°„ ë³µì¡ë„ : 4^8 x 8 x 8 -> `O(NM)`

---

### ğŸ“Œ **ì•Œê³ ë¦¬ì¦˜ ì„¤ëª…**
1. Node ê°ì²´ë¡œ cctv ì •ë³´ë¥¼ ì…ë ¥ ë°›ëŠ”ë‹¤
2. cctv.number(cctv ë²ˆí˜¸) 1~5ë²ˆê¹Œì§€ë§Œ ArrayList<>(); ì— ì¶”ê°€
3. dfs(int depth, int[][] board)
- base conditionê°€ if(depth==cctvList.size)ë  ë•Œ ë°˜í™˜
- í˜„ì¬ CCTV ê°ì²´ ìƒíƒœë¥¼ êº¼ë‚´ë©´ì„œ switch(cctv ë²ˆí˜¸ì— ë”°ë¼ì„œ) ë³µì‚¬í•œ ë°°ì—´ì„ ì¬ê·€ íƒìƒ‰

```java
// ë²ˆí˜¸ì— ë”°ë¼ì„œ ê´€ì°° ë°©í–¥ ëŒë¦¼ í›„ ì¬ê·€ íƒìƒ‰
switch (cctv.number){
            case 1:
                for(int d=0; d<4; d++){
                    int[][] copy = copyBoard(board);
                    simulation(copy, cctv.x, cctv.y, d); // ìš°
                    dfs(depth+1, copy);
                }
                break;
            case 2:
                for(int d=0; d<4; d++){
                    int[][] copy = copyBoard(board);
                    simulation(copy, cctv.x, cctv.y, d); // ìš°
                    simulation(copy, cctv.x, cctv.y, (d+2)%4); // ì¢Œ
                    dfs(depth + 1, copy);
                }
                break;
            case 3:
                for(int d=0; d<4; d++){
                    int[][] copy = copyBoard(board);
                    simulation(copy, cctv.x, cctv.y, d); // ìš°
                    simulation(copy, cctv.x, cctv.y, (d+1)%4); // ìƒ
                    dfs(depth + 1, copy);
                }
                break;
            case 4:
                for(int d=0; d<4; d++){
                    int[][] copy = copyBoard(board);
                    simulation(copy, cctv.x, cctv.y, d); // ìš°
                    simulation(copy, cctv.x, cctv.y, (d+1)%4); // ìƒ
                    simulation(copy, cctv.x, cctv.y, (d+2)%4); // ì¢Œ
                    dfs(depth + 1, copy);
                }
                break;
            case 5:
                int[][] copy = copyBoard(board);
                for(int d=0; d<4; d++){
                    simulation(copy, cctv.x, cctv.y, d); // ìƒí•˜ì¢Œìš°
                }
                dfs(depth + 1, copy);
                break;
        }
```

4. dfs íƒìƒ‰í•˜ë©´ì„œ ì¢Œí‘œ ê°±ì‹ 
- `ì¢…ë£Œ ì¡°ê±´` : `ì¢Œí‘œ ê²½ê³„ë¥¼ ë²—ì–´ë‚˜ëŠ” ê²½ìš°`, `6(ë²½)ì„ ë§Œë‚  ê²½ìš° `
- ê°ì‹œí•œ ëŒ€ìƒì€ '#' ëŒ€ì‹  ìˆ«ì 7ë¡œ ëŒ€ì²´
```java
private static void simulation(int[][] board, int x, int y, int dir){
        while(true){
            x += dx[dir];
            y += dy[dir];
            if(!isValid(x, y)){ // ê²½ê³„ ë²—ì–´ë‚˜ë©´ ì¢…ë£Œ
                break;
            }
            if(board[x][y]==6){
                break;
            }
            if(board[x][y]==0){ // ê°ì‹œí•œ ëŒ€ìƒ
                board[x][y] = 7; // ê°ì‹œí•œ ì˜ì—­ì„ #ëŒ€ì‹  7ë¡œ ë°”ê¿ˆ
            }
        }
    }
```
5. `board[i][j]==0`ì˜ ê°’ì„ counting í•¨ìˆ˜ë¡œ ìµœì†Ÿê°’ ê°±ì‹ í•˜ë©° ì¹´ìš´íŠ¸


### ğŸ“Œ **ì‹¤íŒ¨ ì‚¬ë¡€ ì½”ë“œ**


```java
    private static int[] rotate(int[] dir, int cnt){
        int[] rotatedBoard = new int[dir.length];
        for(int i = 0; (i < dir.length; i++){
            rotatedBoard[i] = (dir [i]+ cnt) % 4;
        }
        return rotatedBoard;
    }
```
```java
 case 5:
             int[][] copy = copyBoard(board);
             for (int d = 0; d < 4; d++) {
             int[][] copied = copyBoard(board);
                 simulation(copied, cctv.x, cctv.y, d);
                 simulation(copied, cctv.x, cctv.y, (d + 1) % 4);
                 simulation(copied, cctv.x, cctv.y, (d + 2) % 4);
                 simulation(copied, cctv.x, cctv.y, (d + 3) % 4);
                 dfs(depth + 1, copied);
              }
             dfs(depth + 1, copy);
             break;
```
---

### ğŸ“Œ **ì‹¤íŒ¨ ì´ìœ  ë° ë°°ìš´ ì **

1. CCTV ì„¤ë§ˆ 1ë²ˆë¶€í„° 5ë²ˆê¹Œì§€ ë‹¤ ëŒë ¤ì•¼ë˜ë‚˜ ì‹¶ì–´ì„œ ë³µì‚¬ ë°°ì—´ì„ ëŒë¦¬ë ¤ê³  í–ˆë‹¤ê°€ ì‹¤íŒ¨
2. breakë¬¸ ì•ˆì¨ì„œ ì‹¤íŒ¨
3. case 5ë•Œ ìƒí•˜ì¢Œìš° ë‹¤ëŒë ¸ë‹¤ê°€ ì‹¤íŒ¨

4. ë¬¸ì œì—ì„œ ì£¼ì–´ì§„ ê²ƒì„ ê·¸ëŒ€ë¡œ êµ¬í˜„í•˜ëŠ”ê²Œ `ì‹œë®¬ë ˆì´ì…˜` ë¬¸ì œ

---

### ğŸ“Œ **ì–»ì–´ê°ˆ ì **
- ê´€ë ¨ ë¬¸ì œ : [Nê³¼ M3](https://www.acmicpc.net/problem/15651)
- ë°±íŠ¸ë˜í‚¹ ê´€ë ¨ ìœ ì‚¬í•œ ë¬¸ì œ
